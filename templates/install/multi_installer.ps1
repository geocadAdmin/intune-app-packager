<#
.SYNOPSIS
    Install script for {{ app_name }} (Multi-installer support)

.DESCRIPTION
    This script handles installation of applications that require multiple installers
    to be run in sequence (e.g., Firebird + EWMapa).
    
    Generated by Intune App Packager
    Application: {{ app_name }}
    Version: {{ app_version }}
    Publisher: {{ publisher }}

.NOTES
    Exit Codes:
    0 - Success
    1 - Generic failure
    1707 - Already installed
    3010 - Reboot required
#>

# Set strict mode
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Logging configuration
$LogPath = "$env:ProgramData\IntuneAppPackager\Logs"
$LogFile = Join-Path $LogPath "{{ app_name }}_Install_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"

# Create log directory if it doesn't exist
if (!(Test-Path $LogPath)) {
    New-Item -Path $LogPath -ItemType Directory -Force | Out-Null
}

# Logging function
function Write-Log {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [Parameter(Mandatory=$false)]
        [ValidateSet('INFO', 'WARN', 'ERROR', 'DEBUG')]
        [string]$Level = 'INFO'
    )
    
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    $logMessage = "[$timestamp] [$Level] $Message"
    
    # Write to log file
    Add-Content -Path $LogFile -Value $logMessage
    
    # Also write to console
    switch ($Level) {
        'ERROR' { Write-Host $logMessage -ForegroundColor Red }
        'WARN'  { Write-Host $logMessage -ForegroundColor Yellow }
        'INFO'  { Write-Host $logMessage -ForegroundColor Green }
        'DEBUG' { Write-Host $logMessage -ForegroundColor Gray }
    }
}

# Get script directory (where installers are located)
$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path

Write-Log "========================================" -Level INFO
Write-Log "Starting installation of {{ app_name }} v{{ app_version }}" -Level INFO
Write-Log "Script directory: $ScriptDir" -Level INFO
Write-Log "========================================" -Level INFO

# Check if already installed
Write-Log "Checking if application is already installed..." -Level INFO
{% for rule in detection_rules %}
{% if rule.type == 'file' %}
if (Test-Path "{{ rule.path }}") {
    {% if rule.check_version %}
    $existingVersion = (Get-Item "{{ rule.path }}").VersionInfo.FileVersion
    Write-Log "Found existing version: $existingVersion" -Level INFO
    if ([Version]$existingVersion -ge [Version]"{{ rule.min_version }}") {
        Write-Log "Application {{ app_name }} version $existingVersion is already installed (required: {{ rule.min_version }})" -Level WARN
        exit 1707
    }
    {% else %}
    Write-Log "Application {{ app_name }} is already installed" -Level WARN
    exit 1707
    {% endif %}
}
{% endif %}
{% endfor %}

# Installer definitions
$Installers = @(
{% for installer in installers %}
    @{
        Name = "{{ installer.name }}"
        Path = Join-Path $ScriptDir "{{ installer.file }}"
        Args = "{{ installer.silent_args }}"
        Timeout = {{ installer.timeout }}
        WaitForCompletion = ${{ installer.wait_for_completion }}
        DependsOn = @({% if installer.depends_on %}{{ installer.depends_on | map('tojson') | join(', ') }}{% endif %})
    }{% if not loop.last %},{% endif %}

{% endfor %}
)

# Track installed components
$InstalledComponents = @()
$FailedComponents = @()

# Function to run installer
function Install-Component {
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$Installer
    )
    
    Write-Log "----------------------------------------" -Level INFO
    Write-Log "Installing component: $($Installer.Name)" -Level INFO
    
    # Check if installer file exists
    if (!(Test-Path $Installer.Path)) {
        Write-Log "Installer not found: $($Installer.Path)" -Level ERROR
        return $false
    }
    
    Write-Log "Installer path: $($Installer.Path)" -Level INFO
    Write-Log "Arguments: $($Installer.Args)" -Level INFO
    Write-Log "Timeout: $($Installer.Timeout) seconds" -Level INFO
    
    try {
        # Start the installation process
        $processArgs = @{
            FilePath = $Installer.Path
            Wait = $Installer.WaitForCompletion
            PassThru = $true
            NoNewWindow = $true
        }
        
        if ($Installer.Args) {
            $processArgs.ArgumentList = $Installer.Args -split ' '
        }
        
        Write-Log "Starting installation process..." -Level INFO
        $process = Start-Process @processArgs
        
        if ($Installer.WaitForCompletion) {
            # Wait with timeout
            $completed = $process.WaitForExit($Installer.Timeout * 1000)
            
            if (!$completed) {
                Write-Log "Installation timed out after $($Installer.Timeout) seconds" -Level ERROR
                $process.Kill()
                return $false
            }
            
            $exitCode = $process.ExitCode
            Write-Log "Installation process exited with code: $exitCode" -Level INFO
            
            # Common exit codes
            # 0 = Success
            # 3010 = Success, reboot required
            # 1641 = Success, reboot initiated
            # 1707 = Already installed
            
            if ($exitCode -eq 0 -or $exitCode -eq 3010 -or $exitCode -eq 1641) {
                Write-Log "Component installed successfully (exit code: $exitCode)" -Level INFO
                if ($exitCode -eq 3010 -or $exitCode -eq 1641) {
                    Write-Log "Reboot will be required after installation" -Level WARN
                    $script:RebootRequired = $true
                }
                return $true
            }
            elseif ($exitCode -eq 1707) {
                Write-Log "Component already installed (exit code: 1707)" -Level WARN
                return $true
            }
            else {
                Write-Log "Installation failed with exit code: $exitCode" -Level ERROR
                return $false
            }
        }
        else {
            Write-Log "Installation started (not waiting for completion)" -Level INFO
            return $true
        }
    }
    catch {
        Write-Log "Exception during installation: $($_.Exception.Message)" -Level ERROR
        Write-Log "Stack trace: $($_.ScriptStackTrace)" -Level DEBUG
        return $false
    }
}

# Function to check dependencies
function Test-Dependencies {
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$Installer
    )
    
    if ($Installer.DependsOn.Count -eq 0) {
        return $true
    }
    
    foreach ($dependency in $Installer.DependsOn) {
        if ($dependency -notin $InstalledComponents) {
            Write-Log "Dependency not met: $dependency must be installed first" -Level ERROR
            return $false
        }
    }
    
    return $true
}

# Main installation loop
$RebootRequired = $false
$installationSuccess = $true

foreach ($installer in $Installers) {
    # Check dependencies
    if (!(Test-Dependencies -Installer $installer)) {
        Write-Log "Cannot install $($installer.Name) - dependencies not met" -Level ERROR
        $FailedComponents += $installer.Name
        $installationSuccess = $false
        continue
    }
    
    # Install component
    $result = Install-Component -Installer $installer
    
    if ($result) {
        $InstalledComponents += $installer.Name
        Write-Log "Component $($installer.Name) installed successfully" -Level INFO
    }
    else {
        $FailedComponents += $installer.Name
        $installationSuccess = $false
        Write-Log "Component $($installer.Name) failed to install" -Level ERROR
        
        # Decide whether to continue or stop
        # For now, we stop on first failure
        break
    }
}

# Create shortcuts if needed
{% if shortcuts %}
Write-Log "Creating shortcuts..." -Level INFO
{% for shortcut in shortcuts %}
try {
    $WshShell = New-Object -ComObject WScript.Shell
    
    # Determine shortcut location
    {% if 'Desktop' in shortcut.locations %}
    $desktopPath = [Environment]::GetFolderPath("Desktop")
    $shortcutPath = Join-Path $desktopPath "{{ shortcut.name }}.lnk"
    
    if (!(Test-Path $shortcutPath)) {
        $Shortcut = $WshShell.CreateShortcut($shortcutPath)
        $Shortcut.TargetPath = "{{ shortcut.target }}"
        {% if shortcut.icon %}
        $Shortcut.IconLocation = "{{ shortcut.icon }}"
        {% endif %}
        $Shortcut.Save()
        Write-Log "Created desktop shortcut: $shortcutPath" -Level INFO
    }
    {% endif %}
    
    {% if 'StartMenu' in shortcut.locations %}
    $startMenuPath = [Environment]::GetFolderPath("StartMenu")
    $shortcutPath = Join-Path $startMenuPath "{{ shortcut.name }}.lnk"
    
    if (!(Test-Path $shortcutPath)) {
        $Shortcut = $WshShell.CreateShortcut($shortcutPath)
        $Shortcut.TargetPath = "{{ shortcut.target }}"
        {% if shortcut.icon %}
        $Shortcut.IconLocation = "{{ shortcut.icon }}"
        {% endif %}
        $Shortcut.Save()
        Write-Log "Created start menu shortcut: $shortcutPath" -Level INFO
    }
    {% endif %}
}
catch {
    Write-Log "Failed to create shortcut {{ shortcut.name }}: $($_.Exception.Message)" -Level WARN
}
{% endfor %}
{% endif %}

# Final summary
Write-Log "========================================" -Level INFO
Write-Log "Installation Summary" -Level INFO
Write-Log "Application: {{ app_name }} v{{ app_version }}" -Level INFO
Write-Log "Installed Components: $($InstalledComponents.Count)" -Level INFO
if ($InstalledComponents.Count -gt 0) {
    $InstalledComponents | ForEach-Object { Write-Log "  - $_" -Level INFO }
}
if ($FailedComponents.Count -gt 0) {
    Write-Log "Failed Components: $($FailedComponents.Count)" -Level ERROR
    $FailedComponents | ForEach-Object { Write-Log "  - $_" -Level ERROR }
}
Write-Log "Log file: $LogFile" -Level INFO
Write-Log "========================================" -Level INFO

# Determine exit code
if (!$installationSuccess) {
    Write-Log "Installation failed" -Level ERROR
    exit 1
}
elseif ($RebootRequired) {
    Write-Log "Installation succeeded - Reboot required" -Level WARN
    exit 3010
}
else {
    Write-Log "Installation completed successfully" -Level INFO
    exit 0
}
